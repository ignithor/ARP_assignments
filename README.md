# ARP_assignments

# Authors

Yui MOMIYAMA
Paul PHAM DANG
Group 3

## How to run

### Dependencies

These dependencies are needed:

- make
- CMake version > 3.6
- libncurses
    sudo apt install libncurses5-dev libncursesw5-dev
- lib cjson
    sudo apt install libcjson-dev

The assignment has been tried using Ubuntu 22.04

### Run the assignments

Simply execute the scripts by executing:

For the assignment 1 :

    ./run_assignment1.sh

For assignment 2 :

    ./run_assignment2.sh

To change from assignment 1 and 2, you can do 
    git checkout assignment

## Rules of the game
The score is updated based on the following conditions.

### Score Increment Rules
- **If \( t <= 30 \):**
  - If the target number is 1:  
    `score_increment = 4 + (30 - t)`
  - If the target number is not 1:  
    `score_increment = 2`
- **If \( t > 30 \):**
  - If the target number is 1:  
    `score_increment = 4`
  - If the target number is not 1:  
    `score_increment = 2`

### Penalty Rules
- **If the player hits a wall:**  
  The score is decreased by 1:  
  `score_decrement = 1`

Summary table of the scoring rules is shown below.

| Condition        | Target Number | Score Change         |
|------------------|---------------|----------------------|
|  t < 30      | 1             | 4 + (30 - t)   |
|  t < 30      | Not 1         | +2       |
|  t >= 30  | 1             | +4              |
|  t >= 30  | Not 1         | +2              |
| Hit a wall       | -             | -1              |

This ensures that:
- Hitting a new target quickly rewards the player more when the target number is 1.
- All other target hits follow a fixed increment.
- Hitting a wall results in a penalty, reducing the score by 1.

## Technical notes

### Software architecture of the second assignment

![plot](/docs/architecture2.jpg)

In the second assignment, the process is executed on two computers within the same LAN.
Each computer runs an identical copy of the assignment, and the two programs are functionally equivalent.
Communication between them is handled via DDS.

As illustrated in the figure, on Computer 1, the operator controls the drone, while the processes O and T on Computer 2 generate obstacles and targets.
However, these roles are interchangeable, allowing the operator on Computer 2 to control the drone while obstacles and targets are generated by processes O and T on Computer 1.


#### target
The target.cpp file defines a `TargetMessage` structure to hold target coordinates and a `TargetPublisher` class to manage the publishing of these messages using the Fast DDS library. The `init` method initializes the necessary DDS entities, such as the `DomainParticipant`, for communication.The topic name is `target`.

#### obstacle
The target.cpp file defines a `ObstacleMessage` structure to hold target coordinates and a `ObstaclePublisher` class to manage the publishing of these messages using the Fast DDS library. The topic name is `obstacle`.

#### server
The server.c subscribes to a topic `target` and `obstacle`. To generate a new targets and obstacles in computer 1.

### Other related files
#### Target.idl
The Target.idl file defines a `Target` structure with two arrays, `target_x` and `target_y`, each containing 9 double values. This structure specifies the data format for target coordinates in a DDS system.

#### Obstacle.idl
The Obstacle.idl file defines a `Obstacle` structure with two arrays, `obstacle_x` and `obstacle_y`, each containing 9 double values. 
